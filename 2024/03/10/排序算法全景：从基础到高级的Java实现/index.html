<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
       
      <meta name="keywords" content="生活，旅行，思考，代码" />
       
      <meta name="description" content="有事者,事竟成;破釜沉舟,百二秦关终归楚;苦心人,天不负;卧薪尝胆,三千越甲可吞吴。" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>排序算法全景：从基础到高级的Java实现 |  何福海的个人博客</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/blog/favicon.ico" />
       
<link rel="stylesheet" href="/blog/dist/main.css">

      
<link rel="stylesheet" href="/blog/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/blog/css/custom.css">
  
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    <link rel="alternate" href="/blog/atom.xml" title="何福海的个人博客" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      
      <canvas width="1777" height="841"
        style="position: fixed; left: 0px; top: 0px; z-index: 99999; pointer-events: none;"></canvas>
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-排序算法全景：从基础到高级的Java实现"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  排序算法全景：从基础到高级的Java实现
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/blog/2024/03/10/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%85%A8%E6%99%AF%EF%BC%9A%E4%BB%8E%E5%9F%BA%E7%A1%80%E5%88%B0%E9%AB%98%E7%BA%A7%E7%9A%84Java%E5%AE%9E%E7%8E%B0/" class="article-date">
  <time datetime="2024-03-09T18:02:17.000Z" itemprop="datePublished">2024-03-10</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/blog/categories/%E7%AE%97%E6%B3%95/">算法</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">4.1k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">16 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="排序算法全景：从基础到高级的Java实现"><a href="#排序算法全景：从基础到高级的Java实现" class="headerlink" title="排序算法全景：从基础到高级的Java实现"></a>排序算法全景：从基础到高级的Java实现</h1><p>排序算法是计算机科学中的一个基础概念，它在数据处理和信息检索中扮演着至关重要的角色。本文将通过几个简单的Java程序，带你了解几种常见的排序算法：插入排序、希尔排序、归并排序、快速排序和选择排序，以及一个用于生成和打印测试数据的工具类。</p>
<h2 id="插入排序：理解排序的核心思想"><a href="#插入排序：理解排序的核心思想" class="headerlink" title="插入排序：理解排序的核心思想"></a>插入排序：理解排序的核心思想</h2><h3 id="什么是插入排序？"><a href="#什么是插入排序？" class="headerlink" title="什么是插入排序？"></a>什么是插入排序？</h3><p>插入排序（Insertion Sort）算法是一种直观且易于理解的排序方法。插入排序的工作原理类似于我们整理扑克牌的方式。想象一下，你手中有一堆未排序的扑克牌，你将它们一张张插入到已经排序好的牌堆中。插入排序算法正是基于这样的思想：它将数组分为已排序和未排序两部分，然后逐个将未排序部分的元素插入到已排序部分的适当位置。</p>
<h3 id="插入排序的Java实现"><a href="#插入排序的Java实现" class="headerlink" title="插入排序的Java实现"></a>插入排序的Java实现</h3><p>让我们通过一个Java程序来具体看看插入排序是如何工作的。这个程序定义了一个名为 <code>_01_InsertionSort</code> 的类，其中包含了排序方法和一些辅助函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">_01_InsertionSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparable[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 寻找元素arr[i]合适的插入位置</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j].compareTo(arr[j - <span class="number">1</span>]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    swap(arr, j, j - <span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(Object[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">t</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个类中，<code>sort</code> 方法接受一个可比较的对象数组 <code>arr</code> 作为参数。方法的核心是一个双重循环：外层循环遍历数组的每个元素，内层循环则负责将当前元素与已排序部分的元素进行比较，并在必要时进行交换。</p>
<p><code>swap</code> 方法是一个辅助函数，用于交换数组中的两个元素。这是在内层循环中，当我们发现需要将一个元素插入到它之前的位置时调用的。</p>
<h3 id="程序的执行"><a href="#程序的执行" class="headerlink" title="程序的执行"></a>程序的执行</h3><p>程序的 <code>main</code> 方法首先生成了一个包含20000个随机整数的数组，然后调用 <code>sort</code> 方法对数组进行排序，最后打印出排序后的数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">20000</span>;</span><br><span class="line">    Integer[] arr = SortTestHelper.generateRandomArray(N, <span class="number">0</span>, <span class="number">100000</span>);</span><br><span class="line">    _01_InsertionSort.sort(arr);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        System.out.print(arr[i]);</span><br><span class="line">        System.out.print(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="插入排序的核心思想"><a href="#插入排序的核心思想" class="headerlink" title="插入排序的核心思想"></a>插入排序的核心思想</h3><p>插入排序的核心思想是分而治之。它将排序问题分解为更小的部分，然后逐个解决。这种方法在数据量较小或者数据基本有序的情况下非常有效，因为它可以减少不必要的比较和交换操作。</p>
<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>通过这个简单的Java程序，我们不仅学习了插入排序算法的实现，还理解了排序算法的一般思想。虽然插入排序在处理大数据集时可能不是最高效的选择，但它的简单性和直观性使其成为理解排序概念的一个良好起点。随着你对算法的深入学习，你将能够掌握更多高级的排序技术，以应对更复杂的数据处理挑战。</p>
<h2 id="希尔排序：一种高效的改进版插入排序"><a href="#希尔排序：一种高效的改进版插入排序" class="headerlink" title="希尔排序：一种高效的改进版插入排序"></a>希尔排序：一种高效的改进版插入排序</h2><p>希尔排序（Shell Sort）是一种对传统插入排序的改进，它通过引入间隔（gap）的概念来提高排序的效率。</p>
<h3 id="希尔排序简介"><a href="#希尔排序简介" class="headerlink" title="希尔排序简介"></a>希尔排序简介</h3><p>希尔排序是由Donald Shell在1959年提出的一种排序算法。它基于插入排序，通过将原始数据集分割成若干个子序列来排序，这些子序列的元素间隔逐渐减小，最后合并为一个有序的序列。</p>
<h3 id="Java实现希尔排序"><a href="#Java实现希尔排序" class="headerlink" title="Java实现希尔排序"></a>Java实现希尔排序</h3><p>让我们通过一个简单的Java程序来实现希尔排序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">_02_ShellSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparable[] arr)</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化间隔</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">gap</span> <span class="operator">=</span> arr.length / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 当间隔大于0时，执行排序</span></span><br><span class="line">        <span class="keyword">while</span> (gap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 遍历数组，间隔为gap</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> gap; i &lt; arr.length; i++) &#123;</span><br><span class="line">                <span class="comment">// 临时存储当前元素</span></span><br><span class="line">                <span class="type">Comparable</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">                <span class="comment">// 对于每个间隔内的元素，进行插入排序</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &gt;= gap &amp;&amp; tmp.compareTo(arr[j - gap]) &lt; <span class="number">0</span>; j -= gap) &#123;</span><br><span class="line">                    <span class="comment">// 将较大的元素向后移动</span></span><br><span class="line">                    arr[j] = arr[j - gap];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 将当前元素放到正确的位置</span></span><br><span class="line">                arr[j] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 缩小间隔，进行下一轮排序</span></span><br><span class="line">            gap /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个实现中，我们首先计算一个初始间隔 <code>gap</code>，然后通过一个循环来逐渐减小这个间隔。在每次循环中，我们对间隔为 <code>gap</code> 的元素进行插入排序。随着间隔的减小，排序的粒度逐渐变细，最终整个数组变得有序。</p>
<h3 id="测试希尔排序"><a href="#测试希尔排序" class="headerlink" title="测试希尔排序"></a>测试希尔排序</h3><p>为了测试我们的希尔排序算法，我们在 <code>main</code> 方法中生成了一个包含2000个随机整数的数组，并对其进行排序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">2000</span>;</span><br><span class="line">    Integer[] arr = SortTestHelper.generateRandomArray(N, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">    _02_ShellSort.sort(arr);</span><br><span class="line">    <span class="comment">// 打印排序后的数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        System.out.print(arr[i]);</span><br><span class="line">        System.out.print(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="希尔排序的核心思想"><a href="#希尔排序的核心思想" class="headerlink" title="希尔排序的核心思想"></a>希尔排序的核心思想</h3><p>希尔排序的核心在于分而治之的策略。它不是一次性对整个数组进行排序，而是先对数组的子序列进行排序，然后逐步缩小子序列的范围，直到整个数组有序。这种方法在处理部分有序的数据时特别有效，因为它可以减少不必要的比较和交换操作。</p>
<h3 id="结语-1"><a href="#结语-1" class="headerlink" title="结语"></a>结语</h3><p>通过这个Java程序，我们不仅学习了希尔排序的实现，还理解了其背后的算法思想。希尔排序是一种简单且高效的排序方法，它在某些情况下比传统的插入排序要快得多。</p>
<h2 id="归并排序：优雅的分而治之艺术"><a href="#归并排序：优雅的分而治之艺术" class="headerlink" title="归并排序：优雅的分而治之艺术"></a>归并排序：优雅的分而治之艺术</h2><p>归并排序（Merge Sort）是一种优雅且高效的排序方法。归并排序通过分而治之的策略，将数据集一分为二，然后递归地对这两部分进行排序，最后将它们合并成一个有序的整体。</p>
<h3 id="归并排序的基本概念"><a href="#归并排序的基本概念" class="headerlink" title="归并排序的基本概念"></a>归并排序的基本概念</h3><p>归并排序的核心在于“分而治之”。这个策略涉及将一个大问题分解成小问题，解决这些小问题，然后将它们的解决方案合并。在排序的上下文中，这意味着将一个未排序的数组分成两半，分别对这两半进行排序，然后将它们合并成一个有序数组。</p>
<h3 id="Java实现归并排序"><a href="#Java实现归并排序" class="headerlink" title="Java实现归并排序"></a>Java实现归并排序</h3><p>让我们通过一个Java程序来实现归并排序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">_03_MergeSort</span> &#123;</span><br><span class="line">    <span class="comment">// 将arr[l...mid]和arr[mid+1...r]两部分进行归并</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(Comparable[] arr, <span class="type">int</span> l, <span class="type">int</span> mid, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">        Comparable[] aux = Arrays.copyOfRange(arr, l, r + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 初始化，i指向左半部分的起始索引位置l；j指向右半部分起始索引位置mid+1</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l, j = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> l; k &lt;= r; k++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i &gt; mid) &#123;  <span class="comment">// 如果左半部分元素已经全部处理完毕</span></span><br><span class="line">                arr[k] = aux[j - l];</span><br><span class="line">                j++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; r) &#123;   <span class="comment">// 如果右半部分元素已经全部处理完毕</span></span><br><span class="line">                arr[k] = aux[i - l];</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (aux[i - l].compareTo(aux[j - l]) &lt; <span class="number">0</span>) &#123;  <span class="comment">// 左半部分所指元素 &lt; 右半部分所指元素</span></span><br><span class="line">                arr[k] = aux[i - l];</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 左半部分所指元素 &gt;= 右半部分所指元素</span></span><br><span class="line">                arr[k] = aux[j - l];</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归使用归并排序,对arr[l...r]的范围进行排序</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparable[] arr, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) / <span class="number">2</span>;</span><br><span class="line">        sort(arr, l, mid);</span><br><span class="line">        sort(arr, mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="comment">// 对于arr[mid] &lt;= arr[mid+1]的情况,不进行merge</span></span><br><span class="line">        <span class="comment">// 对于近乎有序的数组非常有效,但是对于一般情况,有一定的性能损失</span></span><br><span class="line">        <span class="keyword">if</span> (arr[mid].compareTo(arr[mid + <span class="number">1</span>]) &gt; <span class="number">0</span>)</span><br><span class="line">            merge(arr, l, mid, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparable[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        sort(arr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个类中，<code>merge</code> 方法负责合并两个已经排序的子数组。<code>sort</code> 方法是递归的核心，它将数组分成两半，然后递归地调用自身来排序这两半。最后，<code>sort</code> 方法提供了一个公共接口来开始排序过程。</p>
<h3 id="测试归并排序"><a href="#测试归并排序" class="headerlink" title="测试归并排序"></a>测试归并排序</h3><p>为了测试归并排序的性能，我们在 <code>main</code> 方法中生成了一个包含1000个随机整数的数组，并对其进行排序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">    Integer[] arr = SortTestHelper.generateRandomArray(N, <span class="number">0</span>, <span class="number">100000</span>);</span><br><span class="line">    _03_MergeSort.sort(arr);</span><br><span class="line">    SortTestHelper.printArray(arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="归并排序的核心思想"><a href="#归并排序的核心思想" class="headerlink" title="归并排序的核心思想"></a>归并排序的核心思想</h3><p>归并排序的核心在于递归和合并。递归地将数组分成更小的部分，直到每个部分只有一个元素（或没有元素），这时数组自然是有序的。然后，通过合并相邻的有序子数组，逐步构建更大的有序数组，最终得到完全有序的原始数组。</p>
<h3 id="结语-2"><a href="#结语-2" class="headerlink" title="结语"></a>结语</h3><p>归并排序是一种非常优雅的排序算法，它不仅在理论上具有优雅的数学美感，而且在实际应用中也非常高效。它的时间复杂度在最好、最坏和平均情况下都是O(n log n)，这使得它在处理大型数据集时特别有用。尽管归并排序需要额外的存储空间来创建辅助数组，但它的稳定性和效率使其成为许多排序场景下的首选算法。</p>
<h2 id="快速排序：分而治之的高效排序算法"><a href="#快速排序：分而治之的高效排序算法" class="headerlink" title="快速排序：分而治之的高效排序算法"></a>快速排序：分而治之的高效排序算法</h2><p>快速排序（Quick Sort）是一种分而治之策略的高效排序方法。快速排序以其平均时间复杂度为O(n log n)而闻名，它在大多数情况下都能提供出色的性能。</p>
<h3 id="快速排序的基本概念"><a href="#快速排序的基本概念" class="headerlink" title="快速排序的基本概念"></a>快速排序的基本概念</h3><p>快速排序的核心在于“分而治之”。这个策略涉及将一个大问题分解成小问题，解决这些小问题，然后将它们的解决方案合并。在排序的上下文中，这意味着将一个未排序的数组分成两半，然后递归地对这两半进行排序，最后将它们合并成一个有序的整体。</p>
<h3 id="Java实现快速排序"><a href="#Java实现快速排序" class="headerlink" title="Java实现快速排序"></a>Java实现快速排序</h3><p>让我们通过一个Java程序来实现快速排序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">_04_QuickSort</span> &#123;</span><br><span class="line">    <span class="comment">// 对arr[l...r]部分进行partition操作</span></span><br><span class="line">    <span class="comment">// 返回p, 使得arr[l...p-1] &lt; arr[p] ; arr[p+1...r] &gt; arr[p]</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(Comparable[] arr, <span class="type">int</span> l, <span class="type">int</span> r)</span>&#123;</span><br><span class="line">        <span class="comment">// 随机在arr[l...r]的范围中, 选择一个数值作为标定点pivot</span></span><br><span class="line">        swap( arr, l , (<span class="type">int</span>)(Math.random()*(r-l+<span class="number">1</span>))+l );</span><br><span class="line">        <span class="type">Comparable</span> <span class="variable">v</span> <span class="operator">=</span> arr[l];</span><br><span class="line">        <span class="comment">// arr[l+1...j] &lt; v ; arr[j+1...i) &gt; v</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> l;</span><br><span class="line">        <span class="keyword">for</span>( <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l + <span class="number">1</span> ; i &lt;= r ; i ++ )</span><br><span class="line">            <span class="keyword">if</span>( arr[i].compareTo(v) &lt; <span class="number">0</span> )&#123;</span><br><span class="line">                j ++;</span><br><span class="line">                swap(arr, j, i);</span><br><span class="line">            &#125;</span><br><span class="line">        swap(arr, l, j);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归使用快速排序,对arr[l...r]的范围进行排序</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparable[] arr, <span class="type">int</span> l, <span class="type">int</span> r)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> partition(arr, l, r);</span><br><span class="line">        sort(arr, l, p-<span class="number">1</span> );</span><br><span class="line">        sort(arr, p+<span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparable[] arr)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        sort(arr, <span class="number">0</span>, n-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(Object[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">t</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 测试 QuickSort</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// Quick Sort也是一个O(nlogn)复杂度的算法</span></span><br><span class="line">        <span class="comment">// 可以在1秒之内轻松处理100万数量级的数据</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">1000000</span>;</span><br><span class="line">        Integer[] arr = SortTestHelper.generateRandomArray(N, <span class="number">0</span>, <span class="number">100000</span>);</span><br><span class="line">        sort(arr);</span><br><span class="line">        SortTestHelper.printArray(arr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个类中，<code>partition</code> 方法负责将数组分成两部分，<code>sort</code> 方法是递归排序的核心，它将数组分成两半，然后递归地对这两半进行排序。<code>swap</code> 方法是一个辅助函数，用于交换数组中的两个元素。</p>
<h3 id="快速排序的核心思想"><a href="#快速排序的核心思想" class="headerlink" title="快速排序的核心思想"></a>快速排序的核心思想</h3><p>快速排序的核心在于选择一个基准值（pivot），然后将数组分成两部分：一部分包含所有小于基准值的元素，另一部分包含所有大于基准值的元素。这个过程称为分区（partitioning）。分区操作完成后，基准值就处于其最终排序位置。然后，我们递归地对基准值左边和右边的子数组进行同样的操作，直到整个数组变得有序。</p>
<h3 id="快速排序的性能"><a href="#快速排序的性能" class="headerlink" title="快速排序的性能"></a>快速排序的性能</h3><p>快速排序的平均时间复杂度为O(n log n)，这使得它在处理大型数据集时非常高效。尽管在最坏情况下，快速排序的时间复杂度会下降到O(n^2)，但通过随机选择基准值，可以大大降低这种最坏情况发生的概率。</p>
<h3 id="结语-3"><a href="#结语-3" class="headerlink" title="结语"></a>结语</h3><p>通过学习快速排序，我们不仅掌握了一种高效的排序技术，还理解了分而治之这一强大的问题解决策略。这种策略在计算机科学中有着广泛的应用，不仅仅是在排序算法中。快速排序的优雅和效率使其成为了许多排序场景下的首选算法。</p>
<h2 id="选择排序：简单而直观的排序算法入门"><a href="#选择排序：简单而直观的排序算法入门" class="headerlink" title="选择排序：简单而直观的排序算法入门"></a>选择排序：简单而直观的排序算法入门</h2><p>选择排序（Selection Sort）算法是一种易于理解和实现的排序方法。选择排序的核心思想是在每一轮迭代中找到最小（或最大）的元素，并将其移动到正确的位置。</p>
<h3 id="选择排序的工作原理"><a href="#选择排序的工作原理" class="headerlink" title="选择排序的工作原理"></a>选择排序的工作原理</h3><p>选择排序算法的工作原理可以概括为以下几个步骤：</p>
<ol>
<li>假设第一个元素已经是排序好的。</li>
<li>在剩余的未排序元素中找到最小（或最大）的元素。</li>
<li>将找到的最小（或最大）元素与当前未排序的第一个元素交换位置。</li>
<li>重复步骤2和3，直到所有元素都被排序。</li>
</ol>
<h3 id="Java实现选择排序"><a href="#Java实现选择排序" class="headerlink" title="Java实现选择排序"></a>Java实现选择排序</h3><p>下面是一个选择排序的Java实现示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">_07_SelectionSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 初始化最小值索引为当前位置</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="comment">// 寻找[i, n)区间里的最小值的索引</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;</span><br><span class="line">                    minIndex = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 交换当前位置和找到的最小值位置的元素</span></span><br><span class="line">            swap(arr, i, minIndex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">20000</span>;</span><br><span class="line">        Integer[] arr = SortTestHelper.generateRandomArray(N, <span class="number">0</span>, <span class="number">100000</span>);</span><br><span class="line">        _07_SelectionSort.sort(arr);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.print(arr[i]);</span><br><span class="line">            System.out.print(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个实现中，<code>sort</code> 方法负责执行排序过程。它首先遍历数组，然后在每次迭代中找到最小值的索引，并将其与当前位置的元素交换。<code>swap</code> 方法是一个辅助函数，用于交换数组中的两个元素。</p>
<h3 id="选择排序的特点"><a href="#选择排序的特点" class="headerlink" title="选择排序的特点"></a>选择排序的特点</h3><p>选择排序的主要特点是简单。它不需要额外的存储空间（除了临时变量），并且实现起来非常直观。然而，选择排序的效率并不是最高的，它的平均和最坏情况时间复杂度都是O(n^2)，这使得它在处理大型数据集时效率较低。</p>
<h3 id="结语-4"><a href="#结语-4" class="headerlink" title="结语"></a>结语</h3><p>选择排序虽然在效率上可能不如其他更高级的排序算法，但它的简单性和易于理解的特点使其成为初学者学习排序算法的良好起点。</p>
<h2 id="生成测试数据和输出测试数据的类"><a href="#生成测试数据和输出测试数据的类" class="headerlink" title="生成测试数据和输出测试数据的类"></a>生成测试数据和输出测试数据的类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SortTestHelper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SortTestHelper</span> &#123;</span><br><span class="line">    <span class="comment">// SortTestHelper不允许产生任何实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SortTestHelper</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 生成有n个元素的随机数组,每个元素的随机范围为[rangeL, rangeR]</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Integer[] generateRandomArray(<span class="type">int</span> n, <span class="type">int</span> rangeL, <span class="type">int</span> rangeR) &#123;</span><br><span class="line">        <span class="keyword">assert</span> rangeL &lt;= rangeR;</span><br><span class="line">        Integer[] arr = <span class="keyword">new</span> <span class="title class_">Integer</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            arr[i] = <span class="keyword">new</span> <span class="title class_">Integer</span>((<span class="type">int</span>)(Math.random() * (rangeR - rangeL + <span class="number">1</span>) + rangeL));</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打印arr数组的所有内容</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printArray</span><span class="params">(Object arr[])</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">            System.out.print( arr[i] );</span><br><span class="line">            System.out.print( <span class="string">&#x27; &#x27;</span> );</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>感谢你的访问，期待与你在技术的道路上相遇！👋🌟🚀</p>
 
      <!-- reward -->
      
      <div id="reword-out">
        <div id="reward-btn">
          打赏
        </div>
      </div>
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>版权声明： </strong>
          
          本博客所有文章除特别声明外，著作权归作者所有。转载请注明出处！
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://bestwishes0203.gitee.io/blog/2024/03/10/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%85%A8%E6%99%AF%EF%BC%9A%E4%BB%8E%E5%9F%BA%E7%A1%80%E5%88%B0%E9%AB%98%E7%BA%A7%E7%9A%84Java%E5%AE%9E%E7%8E%B0/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/Java/" rel="tag">Java</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/blog/2024/03/11/%E6%8B%BC%E5%9B%BE%E5%B0%8F%E6%B8%B8%E6%88%8F%E5%88%B6%E4%BD%9C%E6%95%99%E7%A8%8B%EF%BC%9A%E7%94%A8HTML5%E5%92%8CJavaScript%E6%89%93%E9%80%A0%E7%BB%8F%E5%85%B8%E6%B8%B8%E6%88%8F/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            拼图小游戏制作教程：用HTML5和JavaScript打造经典游戏
          
        </div>
      </a>
    
    
      <a href="/blog/2024/03/09/%E6%89%93%E9%80%A0%E4%BD%A0%E7%9A%84HTML5%E6%89%93%E5%9C%B0%E9%BC%A0%E6%B8%B8%E6%88%8F%EF%BC%9A%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">打造你的HTML5打地鼠游戏：零基础入门教程</div>
      </a>
    
  </nav>

  
   
  
   
    <script src="https://cdn.staticfile.org/twikoo/1.4.18/twikoo.all.min.js"></script>
    <div id="twikoo" class="twikoo"></div>
    <script>
        twikoo.init({
            envId: ""
        })
    </script>
 
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2022-2024
        <i class="ri-heart-fill heart_icon"></i> 何福海
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/blog/"><img src="/blog/images/ayer.png" alt="何福海的个人博客"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/blog/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/blog/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/blog/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/blog/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/blog/tags/%E6%97%85%E8%A1%8C/">旅行</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="https://wallpaper.seenav.cn/">壁纸</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/blog/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/blog/2022/01/01/%E5%85%B3%E4%BA%8E%E6%88%91/">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/blog/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯奶茶吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/blog/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/blog/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/blog/js/jquery-3.6.0.min.js"></script>
 
<script src="/blog/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/blog/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/blog/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/blog/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->
 
<script src="/blog/js/clickBoom2.js"></script>
 
<!-- CodeCopy -->
 
<link rel="stylesheet" href="/blog/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->
 
<script src="/blog/js/dz.js"></script>
 
<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    <div id="music">
    
    
    
    <iframe frameborder="no" border="1" marginwidth="0" marginheight="0" width="200" height="52"
        src="//music.163.com/outchain/player?type=2&id=1497588709&auto=0&height=32"></iframe>
</div>

<style>
    #music {
        position: fixed;
        right: 15px;
        bottom: 0;
        z-index: 998;
    }
</style>
    
    

  </div>
</body>

</html>